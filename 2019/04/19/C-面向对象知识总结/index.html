<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">







  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/images/manifest.json">




  <meta name="keywords" content="C++,">





  <link rel="alternate" href="/atom.xml" title="煊奕" type="application/atom+xml">






<meta name="description" content="借我怦然心动如往昔，借我安适的清晨与傍晚">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面向对象知识总结">
<meta property="og:url" content="https://clwsec.top/2019/04/19/C-面向对象知识总结/index.html">
<meta property="og:site_name" content="煊奕">
<meta property="og:description" content="借我怦然心动如往昔，借我安适的清晨与傍晚">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-19T11:20:10.227Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++面向对象知识总结">
<meta name="twitter:description" content="借我怦然心动如往昔，借我安适的清晨与傍晚">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":10,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://clwsec.top/2019/04/19/C-面向对象知识总结/">





  <title>C++面向对象知识总结 | 煊奕</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">煊奕</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">No pains No gains</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-链接">
          <a href="/links/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            链接
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://clwsec.top/2019/04/19/C-面向对象知识总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lei">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="煊奕">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++面向对象知识总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-19T18:57:53+08:00">
                2019-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/reprint/" itemprop="url" rel="index">
                    <span itemprop="name">reprint</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.8k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <blockquote class="blockquote-center">借我怦然心动如往昔，借我安适的清晨与傍晚</blockquote>

<a id="more"></a>
<p>文章转自：</p>
<blockquote>
<p><a href="https://blog.csdn.net/u012864854/article/details/79777991" target="_blank" rel="noopener">https://blog.csdn.net/u012864854/article/details/79777991</a></p>
</blockquote>
<h3 id="面向对象三大特性？"><a href="#面向对象三大特性？" class="headerlink" title="面向对象三大特性？"></a>面向对象三大特性？</h3><p>1.封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。<br>2.继承性：让某种类型对象获得另一个类型对象的属性和方法。<br>3.多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）</p>
<h3 id="public-protected-private的区别？"><a href="#public-protected-private的区别？" class="headerlink" title="public/protected/private的区别？"></a>public/protected/private的区别？</h3><p>public的变量和函数在类的内部外部都可以访问。<br>protected的变量和函数只能在类的内部和其派生类中访问。<br>private修饰的元素只能在类内访问。</p>
<h3 id="对象存储空间？"><a href="#对象存储空间？" class="headerlink" title="对象存储空间？"></a>对象存储空间？</h3><p>1.非静态成员的数据类型大小之和。<br>2.编译器加入的额外成员变量（如指向虚函数的指针）<br>3.为了边缘对齐优化加入的padding</p>
<h3 id="C-空类有哪些成员函数"><a href="#C-空类有哪些成员函数" class="headerlink" title="C++空类有哪些成员函数"></a>C++空类有哪些成员函数</h3><p>1.首先，空类对象大小为1字节。<br>2.默认函数有</p>
<ul>
<li>构造函数 <code>A()</code>;</li>
<li>析构函数 <code>~A(void)</code>;</li>
<li>拷贝构造函数 <code>A(const A &amp;a)</code>;</li>
<li>赋值运算符 <code>A&amp; operate =(const A &amp;a)</code>;</li>
</ul>
<h3 id="构造函数能否为虚函数，析构函数呢？"><a href="#构造函数能否为虚函数，析构函数呢？" class="headerlink" title="构造函数能否为虚函数，析构函数呢？"></a>构造函数能否为虚函数，析构函数呢？</h3><p>析构函数：</p>
<p>1.析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。<br>2.只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。<br>3.析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</p>
<p>构造函数：</p>
<p>1.构造函数不能定义为虚函数。虚函数对应一个虚函数表（vtable），可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。</p>
<h3 id="构造函数和析构函数能否调用虚函数？"><a href="#构造函数和析构函数能否调用虚函数？" class="headerlink" title="构造函数和析构函数能否调用虚函数？"></a>构造函数和析构函数能否调用虚函数？</h3><p>1.从语法上讲，调用完全没有问题。但是从效果上看，往往不能达到需要的目的。<br>2.假设一个基类A的构造函数中调用了一个虚函数。派生类B继承自A 。当用构造函数创建一个B类对象时，先调用基类A的构造函数，而此时编译器认为正在创建的对象的类型是A，所以虚函数是A类的虚函数。析构时同理，派生类成员先被析构了，当进入基类的析构函数时，就认为对象是基类对象调用基类的虚函数。</p>
<h3 id="构造函数调用顺序，析构函数呢？"><a href="#构造函数调用顺序，析构函数呢？" class="headerlink" title="构造函数调用顺序，析构函数呢？"></a>构造函数调用顺序，析构函数呢？</h3><p>1.首先，基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。<br>2.其次，成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。<br>3.最后，派生类的构造函数。</p>
<p>4.析构函数与之相反。</p>
<h3 id="拷贝构造函数中深拷贝和浅拷贝区别？"><a href="#拷贝构造函数中深拷贝和浅拷贝区别？" class="headerlink" title="拷贝构造函数中深拷贝和浅拷贝区别？"></a>拷贝构造函数中深拷贝和浅拷贝区别？</h3><p>1.深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。<br>2.浅拷贝仅仅是拷贝指针字面值。<br>当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。</p>
<h3 id="拷贝构造函数和赋值运算符重载的区别？"><a href="#拷贝构造函数和赋值运算符重载的区别？" class="headerlink" title="拷贝构造函数和赋值运算符重载的区别？"></a>拷贝构造函数和赋值运算符重载的区别？</h3><p>1.拷贝构造函数是函数，赋值运算符是运算符重载。</p>
<p>2.拷贝构造函数<code>会生成</code>新的类对象，赋值运算符不能。</p>
<p>3.拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果被赋值对象有内存分配则需要先把内存释放掉。</p>
<p>4.形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现”=”的地方都是使用赋值运算符，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s;</span><br><span class="line">Student s1 = <span class="number">2</span>;    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">Student s2;</span><br><span class="line">s2 = s;    <span class="comment">// 赋值运算符操作(没有新对象产生)</span></span><br></pre></td></tr></table></figure>
<p>5.<strong>类中有指针变量指向动态分配的内存资源时，要重写析构函数、拷贝构造函数和赋值运算符</strong></p>
<h3 id="拷贝构造函数在什么时候会被调用？"><a href="#拷贝构造函数在什么时候会被调用？" class="headerlink" title="拷贝构造函数在什么时候会被调用？"></a>拷贝构造函数在什么时候会被调用？</h3><p>假设Person是一个类。<br>Person p(q) //使用拷贝构造函数来创建实例p;<br>Person p = q; //使用拷贝构造函数来定义实例p时初始化p<br>f(p) //p参数进行值传递时，会调用复制构造函数创建一个局部对象</p>
<h3 id="虚函数和纯虚函数区别？"><a href="#虚函数和纯虚函数区别？" class="headerlink" title="虚函数和纯虚函数区别？"></a>虚函数和纯虚函数区别？</h3><p>1.虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）</p>
<p>2.虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求<strong>函数名、返回值类型、参数个数和类型</strong>全部与基类函数相同。<br>3.纯虚函数只是相当于一个接口名，含有纯虚函数的类不能够实例化。</p>
<h3 id="虚函数机制带来的开销有哪些"><a href="#虚函数机制带来的开销有哪些" class="headerlink" title="虚函数机制带来的开销有哪些?"></a>虚函数机制带来的开销有哪些?</h3><p>主要是虚表的存储开销、函数通过指针使用带来的时间开销。</p>
<h3 id="覆盖、隐藏和重载的区别？"><a href="#覆盖、隐藏和重载的区别？" class="headerlink" title="覆盖、隐藏和重载的区别？"></a>覆盖、隐藏和重载的区别？</h3><p>重写和重载主要有以下几点不同</p>
<p>1.范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。<br>2.参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一定不同。<br>3.virtual 的区别：重写的基类中被重写的函数必须要有 virtual 修饰，而重载函数和被重载函数可以被virtual 修饰，也可以没有。</p>
<p>隐藏和重写、重载有以下几点不同</p>
<p>1.与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中<br>2.参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。当参数不相同时，无论基类中的参数是否被 virtual 修饰，基类的函数都是被隐藏，而不是被重写</p>
<p>说明：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完全不同的，覆盖是动态绑定的多态，而重载是静态绑定的多态。</p>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>public　　    父类的访问级别不变<br>protected     父类的public成员在派生类编程protected，其余的不变<br>private        父类的所有成员变成private</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">cout</span> &lt;&lt;<span class="string">"base"</span>&lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printhello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">cout</span> &lt;&lt;<span class="string">"helo"</span>&lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printnohello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">cout</span> &lt;&lt;<span class="string">"no hello"</span>&lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printb</span><span class="params">()</span> </span>&#123; printhello(); &#125;</span><br><span class="line">    <span class="comment">// void printc() &#123; printnohello(); &#125; //printnohello是父类的私有函数，不可访问</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  base a;</span><br><span class="line">  a.printa();</span><br><span class="line">  derived b;</span><br><span class="line">  b.printb();</span><br><span class="line">  <span class="comment">//a.printhello(); //printhello是类base的protected函数，不可访问。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简述多态的实现原理"><a href="#简述多态的实现原理" class="headerlink" title="简述多态的实现原理"></a>简述多态的实现原理</h3><p>1.编译器发现一个类中有虚函数，便会立即为此类生成虚函数表vtable。虚函数表的各表项为指向对应虚函数的指针。编译器还会在此类中隐含插入一个指针 vptr指向虚函数表。调用此类的构造函数时，在类的构造函数中，编译器会隐含执行 vptr 与 vtable 的关联代码，将 vptr 指向对应的 vtable，将类与此类的 vtable 联系了起来。另外在调用类的构造函数时，指向基础类的指针此时已经变成指向具体的类的 this 指针，这样依靠此 this 指针即可得到正确的 vtable。</p>
<p>2.如此才能真正与函数体进行连接，这就是动态联编，实现多态的基本原理。</p>
<h3 id="c-空类的成员函数"><a href="#c-空类的成员函数" class="headerlink" title="c++空类的成员函数"></a>c++空类的成员函数</h3><p>缺省的构造函数<br>缺省的拷贝构造函数<br>缺省的赋值运算符<br>缺省的析构函数<br>缺省的取址运算符<br>缺省的取址运算符const</p>
<p>注意：只有当实际使用这些函数的时候，编译器才会去定义它们。</p>
<h3 id="在main执行之前执行的代码可能是什么？"><a href="#在main执行之前执行的代码可能是什么？" class="headerlink" title="在main执行之前执行的代码可能是什么？"></a>在main执行之前执行的代码可能是什么？</h3><p>全局对象的构造函数。</p>
<h3 id="哪几种情况必须用到初始化成员列表？"><a href="#哪几种情况必须用到初始化成员列表？" class="headerlink" title="哪几种情况必须用到初始化成员列表？"></a>哪几种情况必须用到初始化成员列表？</h3><p>1.类中有const成员。<br>2.类中有reference成员。<br>3.调用一个基类的构造函数，而该函数有一组参数。<br>4.调用一个数据成员对象的构造函数，而该函数有一组参数。</p>
<h3 id="什么是虚指针？"><a href="#什么是虚指针？" class="headerlink" title="什么是虚指针？"></a>什么是虚指针？</h3><p>1.虚指针或虚函数指针是虚函数的实现细节。<br>2.虚指针指向虚表结构。</p>
<h3 id="重载和函数模板的区别？"><a href="#重载和函数模板的区别？" class="headerlink" title="重载和函数模板的区别？"></a>重载和函数模板的区别？</h3><p>1.重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。<br>2.模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于<strong>参数个数相同</strong>而<strong>类型不同</strong>的函数。</p>
<h3 id="this指针是什么？"><a href="#this指针是什么？" class="headerlink" title="this指针是什么？"></a>this指针是什么？</h3><p>1.this指针是类的指针，指向对象的首地址。<br>2.this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给this。所以this指针只能在成员函数中使用。在静态成员函数中不能用this。<br>3.this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</p>
<h3 id="类模板是什么？"><a href="#类模板是什么？" class="headerlink" title="类模板是什么？"></a>类模板是什么？</h3><p>1.用于解决多个功能相同、数据类型不同的类需要重复定义的问题。<br>2.在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。<br>3.类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。</p>
<h3 id="构造函数和析构函数调用时机？"><a href="#构造函数和析构函数调用时机？" class="headerlink" title="构造函数和析构函数调用时机？"></a>构造函数和析构函数调用时机？</h3><p>1.全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。<br>2.局部自动对象：建立对象时调用构造函数，函数结束时调用析构函数。<br>3.动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。<br>4.静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。</p>
<h3 id="delete-this"><a href="#delete-this" class="headerlink" title="delete this"></a>delete this</h3><p>1.类的成员函数中能不能调用delete this？<br>可以。假设一个成员函数release，调用了delete this。那么这个对象在调用release方法后，还可以进行其他操作，比如调用其他方法。前提是：被调用的方法不涉及这个对象的数据成员和虚函数，否则会出现不可预期的问题。</p>
<p>2.为什么是不可预期的问题？<br>这涉及到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。但是其中的值是不确定的。</p>
<p>3.类的析构函数中调用delete this，会发生什么？<br>导致栈溢出。delete的本质是为将被释放的内存调用一个或多个析构函数，然后，释放内存。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h3 id="当把一个派生类对象指针赋值给其基类指针时会发生什么样的行为"><a href="#当把一个派生类对象指针赋值给其基类指针时会发生什么样的行为" class="headerlink" title="当把一个派生类对象指针赋值给其基类指针时会发生什么样的行为"></a>当把一个派生类对象指针赋值给其基类指针时会发生什么样的行为</h3><p>当使用基类的指针指向一个派生类的对象时，编译器会安插相应的代码，调整指针的指向，使基类的指针指向派生类对象中其对应的基类子对象的起始处。</p>
<h3 id="在类的构造函数里面直接使用-memset-this-0-sizeof-this-来初始化整个类里会发生什么？"><a href="#在类的构造函数里面直接使用-memset-this-0-sizeof-this-来初始化整个类里会发生什么？" class="headerlink" title="在类的构造函数里面直接使用 memset(this,0,sizeof(*this)) 来初始化整个类里会发生什么？"></a>在类的构造函数里面直接使用 memset(this,0,sizeof(*this)) 来初始化整个类里会发生什么？</h3><p>将所有非静态成员变量置0。当有虚函数的时候，虚函数表指针vptr会被置成空。</p>
<h3 id="多继承有什么问题？"><a href="#多继承有什么问题？" class="headerlink" title="多继承有什么问题？"></a>多继承有什么问题？</h3><p>1.多继承比单继承复杂，引入了歧义的问题（ 如果基类的成员函数名称相同，匹配度相同, 则会造成歧义）<br>2.菱形的多继承，导致虚继承的必要性；但虚继承在大小、速度、初始化/赋值的复杂性上有不小的代价，当虚基类中没有数据时还是比较合适的。</p>
<h3 id="析构函数能抛出异常吗？"><a href="#析构函数能抛出异常吗？" class="headerlink" title="析构函数能抛出异常吗？"></a>析构函数能抛出异常吗？</h3><p>1.不能，也不应该抛出。<br>2.如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。<br>3.通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</p>
<h3 id="为什么内联函数，构造函数，静态成员函数不能为virtual函数"><a href="#为什么内联函数，构造函数，静态成员函数不能为virtual函数" class="headerlink" title="为什么内联函数，构造函数，静态成员函数不能为virtual函数"></a>为什么内联函数，构造函数，静态成员函数不能为virtual函数</h3><p>1.内联函数<br>内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数。</p>
<p>2.构造函数<br>构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数</p>
<p>3.静态成员函数<br>静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别。</p>
<p>4.友元函数<br>C++不支持友元函数的继承，对于没有继承性的函数没有虚函数</p>
<h3 id="如何定义一个只能在堆上生成对象的类"><a href="#如何定义一个只能在堆上生成对象的类" class="headerlink" title="如何定义一个只能在堆上生成对象的类"></a>如何定义一个只能在堆上生成对象的类</h3><p>1.只能在堆上，析构函数设为protected。<br>编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。</p>
<p>2.类中必须提供一个destroy函数，调用delete this，来进行内存空间的释放。类对象使用完成后，必须调用destroy函数。</p>
<p>3.用new建立对象，destroy销毁对象很奇怪。可以用一个静态成员函数将new封装起来。同时将构造函数设为protected。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    A()&#123;&#125;;</span><br><span class="line">    ~A()&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> A* <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="如何定义一个只能在栈上生成对象的类？"><a href="#如何定义一个只能在栈上生成对象的类？" class="headerlink" title="如何定义一个只能在栈上生成对象的类？"></a>如何定义一个只能在栈上生成对象的类？</h3><p>只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设为私有即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;;</span><br><span class="line">    ~A()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span>  <span class="title">new</span> <span class="params">( <span class="keyword">size_t</span>  t)</span></span>&#123;&#125;      <span class="comment">// 注意函数的第一个参数和返回值都是固定的</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span>  <span class="title">delete</span> <span class="params">( <span class="keyword">void</span> * ptr)</span></span>&#123;&#125;  <span class="comment">// 重载了new就需要重载delete</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1.在cpp中必须对它进行初始化：<code>int A::s_value = 0;</code> // 注意，这里没有static的修饰！</p>
<p>2.类的静态成员是该类所有实例的共用成员，也就是在该类的范畴内是个全局变量，也可以理解为是一个名为<code>A::s_value</code>的全局变量，只不过它是带有类安全属性的；道理很简单，因为它是在程序初始化的时候分配的，所以只分配一次，所以就是共用的；</p>
<p>3.类中只是声明，在cpp中才是初始化，可以在初始化的代码上放个断点，在程序执行main的第一条语句之前就会先走到那；如果你的静态成员是个类，那么就会调用到它的构造函数；</p>
<h3 id="类的静态函数"><a href="#类的静态函数" class="headerlink" title="类的静态函数"></a>类的静态函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1.实现的时候也不需要static的修饰，因为static是声明性关键字；<br>2.类的静态函数是在该类的范畴内的全局函数，不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用；实际上，它就是增加了类的访问权限的全局函数：<code>void A::fun(int);</code><br>3.静态成员函数可以继承和覆盖,但无法是虚函数；</p>
<hr>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    lei
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://clwsec.top/2019/04/19/C-面向对象知识总结/" title="C++面向对象知识总结">https://clwsec.top/2019/04/19/C-面向对象知识总结/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"> <i class="fa fa-tag"></i> C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/17/C-基础知识总结/" rel="next" title="C++基础知识总结">
                <i class="fa fa-chevron-left"></i> C++基础知识总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/30/Python记录一/" rel="prev" title="Python记录一">
                Python记录一 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="lei">
            
              <p class="site-author-name" itemprop="name">lei</p>
              <p class="site-description motion-element" itemprop="description">业精于勤 荒于嬉 行成于思 毁于随</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/clwsec" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="email:clwsec@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/7e18a3f52ba3" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-heartbeat"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="qq:740455490" target="_blank" title="QQ">
                      
                        <i class="fa fa-fw fa-qq"></i>QQ</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-globe"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.baidu.com/" title="百度" target="_blank">百度</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.zhihu.com/" title="知乎" target="_blank">知乎</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.w3school.com.cn/" title="W3school" target="_blank">W3school</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.runoob.com/" title="菜鸟" target="_blank">菜鸟</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象三大特性？"><span class="nav-number">1.</span> <span class="nav-text">面向对象三大特性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#public-protected-private的区别？"><span class="nav-number">2.</span> <span class="nav-text">public/protected/private的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象存储空间？"><span class="nav-number">3.</span> <span class="nav-text">对象存储空间？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-空类有哪些成员函数"><span class="nav-number">4.</span> <span class="nav-text">C++空类有哪些成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数能否为虚函数，析构函数呢？"><span class="nav-number">5.</span> <span class="nav-text">构造函数能否为虚函数，析构函数呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数和析构函数能否调用虚函数？"><span class="nav-number">6.</span> <span class="nav-text">构造函数和析构函数能否调用虚函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数调用顺序，析构函数呢？"><span class="nav-number">7.</span> <span class="nav-text">构造函数调用顺序，析构函数呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拷贝构造函数中深拷贝和浅拷贝区别？"><span class="nav-number">8.</span> <span class="nav-text">拷贝构造函数中深拷贝和浅拷贝区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拷贝构造函数和赋值运算符重载的区别？"><span class="nav-number">9.</span> <span class="nav-text">拷贝构造函数和赋值运算符重载的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拷贝构造函数在什么时候会被调用？"><span class="nav-number">10.</span> <span class="nav-text">拷贝构造函数在什么时候会被调用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数和纯虚函数区别？"><span class="nav-number">11.</span> <span class="nav-text">虚函数和纯虚函数区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数机制带来的开销有哪些"><span class="nav-number">12.</span> <span class="nav-text">虚函数机制带来的开销有哪些?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖、隐藏和重载的区别？"><span class="nav-number">13.</span> <span class="nav-text">覆盖、隐藏和重载的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承方式"><span class="nav-number">14.</span> <span class="nav-text">继承方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简述多态的实现原理"><span class="nav-number">15.</span> <span class="nav-text">简述多态的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-空类的成员函数"><span class="nav-number">16.</span> <span class="nav-text">c++空类的成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在main执行之前执行的代码可能是什么？"><span class="nav-number">17.</span> <span class="nav-text">在main执行之前执行的代码可能是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哪几种情况必须用到初始化成员列表？"><span class="nav-number">18.</span> <span class="nav-text">哪几种情况必须用到初始化成员列表？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是虚指针？"><span class="nav-number">19.</span> <span class="nav-text">什么是虚指针？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载和函数模板的区别？"><span class="nav-number">20.</span> <span class="nav-text">重载和函数模板的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this指针是什么？"><span class="nav-number">21.</span> <span class="nav-text">this指针是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类模板是什么？"><span class="nav-number">22.</span> <span class="nav-text">类模板是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数和析构函数调用时机？"><span class="nav-number">23.</span> <span class="nav-text">构造函数和析构函数调用时机？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete-this"><span class="nav-number">24.</span> <span class="nav-text">delete this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#当把一个派生类对象指针赋值给其基类指针时会发生什么样的行为"><span class="nav-number">25.</span> <span class="nav-text">当把一个派生类对象指针赋值给其基类指针时会发生什么样的行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在类的构造函数里面直接使用-memset-this-0-sizeof-this-来初始化整个类里会发生什么？"><span class="nav-number">26.</span> <span class="nav-text">在类的构造函数里面直接使用 memset(this,0,sizeof(*this)) 来初始化整个类里会发生什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多继承有什么问题？"><span class="nav-number">27.</span> <span class="nav-text">多继承有什么问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#析构函数能抛出异常吗？"><span class="nav-number">28.</span> <span class="nav-text">析构函数能抛出异常吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么内联函数，构造函数，静态成员函数不能为virtual函数"><span class="nav-number">29.</span> <span class="nav-text">为什么内联函数，构造函数，静态成员函数不能为virtual函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何定义一个只能在堆上生成对象的类"><span class="nav-number">30.</span> <span class="nav-text">如何定义一个只能在堆上生成对象的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何定义一个只能在栈上生成对象的类？"><span class="nav-number">31.</span> <span class="nav-text">如何定义一个只能在栈上生成对象的类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的静态成员"><span class="nav-number">32.</span> <span class="nav-text">类的静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的静态函数"><span class="nav-number">33.</span> <span class="nav-text">类的静态函数</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lei</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">72k</span>
  
</div>







        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
